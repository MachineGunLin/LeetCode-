/*
用一个哈希表，一遍遍历字符串S的所有长度为k的字串，把字串存储在哈希表中，
这样最后如果哈希表的大小是2 ^ K (或者说1 << k)，那么就说明字符串s包含
所有长度为k的二进制子串。
为什么？ 因为是二进制的，长度为k的二进制子串总的个数就是2 ^ k个，
所以如果遍历s的所有长度为k的子串个数恰好也是2 ^ k,就说明S包含所有长度为k的二进制子串。

这里还有一个小技巧，哈希表中不存储字符串，因为字符串比较大，所以我们把长度为k的
二进制子串转换成对应的十进制整数，这样哈希表只需要存储整数就可以了。

因为只需要遍历一遍字符串s的所有长度为k的子串，所以时间复杂度是O(n), n是s的长度
*/

class Solution {
public:
    bool hasAllCodes(string s, int k) {
        unordered_set<int> hashTable;
        for(int i = 0, w = 0; i < s.size(); i++) {    //w是长度为k的二进制子串对应的十进制整数
            w = w * 2 + s[i] - '0';                 //每次加上二进制子串的最后一个位
            if(i >= k) {                          //如果i大于等于k，需要去掉后面的位数，保证子串长度是k
                w -= (s[i - k] - '0') << k;
            }
            if(i >= k - 1) {                //如果i大于等于k-1，说明子串长度已经达到了k，可以插入到哈希表中
                hashTable.insert(w);
            }
        }
        return hashTable.size() == (1 << k);      //哈希表中长度为k的子串个数如果是2 ^ k, 就说明字符串s包含所有长度为k的二进制子串
    }
};
