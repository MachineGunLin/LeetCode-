/*
题意是给定一个已排序数组，我们需要原地修改数组，使得相同元素最多留下2个，并且返回新的数组的大小。

这题还是双指针做法，最开始左右指针都在0位置，左指针表示新的已排序数组的末尾元素位置，
右指针从左向右遍历逐个判断元素是否可以加入“新数组”中。

由于相同元素最多只能留两个，且数组是已排序的，所以对于一个新元素num，我们只需判断它和左指针所指元素以及
左指针前一个位置的元素是否相等，如果都相等，说明这个元素以及出现两次了，所以右指针元素是无效的。
只要有一个元素和右指针所指不等，说明右指针所指元素是有效的，让左指针位置的元素为这个元素，左指针右移一个位置。

这样右指针遍历到数组末尾时，左指针指向的位置就是“新数组”的大小，返回这个位置即可。
*/

class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int k = 0;                  //k是左指针
        for(auto num : nums) {            //右指针不写了，直接用auto关键字判断
            if(k < 2 || num != nums[k - 2] || num != nums[k - 1]) {      //如果左指针小于2，则肯定可以加入新元素（不会有两个重复元素）； 如果右指针所指元素和左指针所指元素或者左指针前一个位置所指元素其中之一不等，说明还能加入右指针所指元素（该元素数量不会超过2）
                nums[k++] = num;               //左指针位置记录这个新元素，左指针右移
            }
        }
        return k;                  //最后左指针的位置就是“新数组”的大小
    }
};
