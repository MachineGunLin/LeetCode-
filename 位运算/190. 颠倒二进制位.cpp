/*
颠倒一个32位无符号整数的二进制位，因为它只有32位，所以我们可以用一个循环，从最低位开始获取它的当前位的数字，然后循环32次把数字加到一个新的32位无符号整数上，然后返回这个32位无符号整数就ok。

对于数字n，要获取最低位的数字就是 n & 1，也可以理解为n >> 0 & 1，意思就是n的二进制表示右移0位（不右移）与1做与运算，因为这个运算是右对齐的，所以只有最低位的数与1做了与运算，和1相与，这个位的数本来是0就是0，本来是1就是1，其他位同理，比如如果要获得第30位（从右往左数第31个位，因为最低位从0开始），就是n >> 30 & i，其他位数同理。
*/

class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res = 0;
        for(int i = 0; i < 32; ++i) {            
            res = (res << 1) + (n >> i & 1);            //之前的res左移一位，相当于乘2，再加上这个新的数
        }
        return res;
    }
};
