/*
按照题目说的规则，不是快乐数的数，会陷入无限循环，永远得不到1，比如18，在第4次迭代的时候计算出来的n是58，在第12次迭代之后n的值还是58，所以就陷入了无限循环之中，所以18不是快乐数。

因此，我们可以用一个set，对于每一次迭代就算出来的n，都先去判断set中是否已经存在这个值了，如果已经存在，说明计算陷入了循环，这个数就不是快乐数。

具体做法：每次循环先把当前n的值加入集合中，方便之后判断循环，每一次计算n的下一次迭代得到的值newN，newN就是把n的所有位置的数的平方和相加得到的数，然后把newN的值再赋给n。
只要n的值不为1（为1就可以返回true了），或者n的值在set中没有出现过，就继续循环。
*/

class Solution {
public:
    bool isHappy(int n) {
        set<int> hash;
        while(true) {
            hash.insert(n);
            int newN = 0;                        //newN是把n的每一位的数的平方和相加得到的数
            while(n != 0) {
                newN += pow(n % 10, 2);
                n /= 10;
            }
            n = newN;                           
            if(n == 1) {                        //退出循环有两种情况：（1）n为1（说明这是一个快乐数）
                break;
            }
            if(hash.count(n) != 0) {            //（2）之前的计算中已经出现了现在这个数，说明陷入了无限循环，这不是一个快乐数
                return false;
            }
        }
        return true;
    }
};
