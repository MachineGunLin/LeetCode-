![](https://img2020.cnblogs.com/blog/2078361/202008/2078361-20200802195820353-258885011.png)

参考[这个链接](https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/xiang-xi-tong-su-de-si-lu-fen-xi-by-windliang-3/)

直接计算阶乘，再求0的个数肯定会溢出，因为阶乘增长的很快。

所以需要观察一下规律，阶乘里出现0，肯定是能被10整除，而10只能由2*5组成，所以问题就转换为阶乘里有几对2和5.

由于2每两个数就出现一次，5要每5个数出现一次，所以阶乘里2的数量肯定比5多，所以问题又转换为寻找阶乘里5的数量。

对于一个比较大的数n，每隔25个数会出现两个5，比如:
.... * (1 * 5) * ... * (1 * 5 * 5) * ... * (2 * 5 * 5) * ... * (3 * 5 * 5) * ... * n
，同理，每隔125(5 * 5 * 5)个数会出现3个5。

所以5出现的规律是：每隔5个数出现一个5，每隔5 * 5个数出现2个5，每隔5 * 5 * 5个数出现3个5，所以最终5的个数就是 n / 5 + n / 25 + n / 125 + .....

根据最前面的分析，5出现的次数就是阶乘中0的个数。

代码如下：

```
class Solution {
public:
    int trailingZeroes(int n) {
        int res = 0;
        while(n > 0) {      // 计算5出现的个数
            n /= 5;
            res += n;
        }
        return res;
    }
};
```
